#Binary Search Questions:-
1)Search in rotated array:-
class Solution {
    public int search(int[] nums, int target) {
    int pivot = Pivot(nums);
    int firstHalf = BS(nums,target,0,pivot);
    if(firstHalf != -1) return firstHalf;
    else return BS(nums, target, pivot + 1, nums.length - 1);    
    }

    public int Pivot(int[] nums){
     int s = 0;
        int e = nums.length - 1;

        while(s <= e){
            int m = s + (e - s) / 2;
            //if we are in descending part of array/unsorted half of rotated array where pivot exists 
            if(m < nums.length - 1){
            if(nums[m] > nums[m + 1]) return m;
            }
            if(m > 0){
            if(nums[m] < nums[m -1]) return m - 1;
            }
            //if we are in first half of ascending order of pivot 
            if(nums[m] > nums[s]) s = m + 1;/*and not s = m because if nums[m] is the pivot then it would have caught in 1st or 2nd condition earlier so as pivot is not at nums[m] we will ignore m and do s = m + 1*/

            //if we are in second half of ascending order of pivot
            else e = m - 1;
        }
        return -1;
    }

    public int BS(int[] nums, int target, int s, int e){
        int start = s;
        int end = e;
        
        while(s <= e){
            int m = s + (e - s) / 2;

            if(nums[m] == target) return m;

            if(nums[m] > target) e = m - 1;
            else s = m + 1;
        }
        return -1;
    }
}

2)Serach in rotated sorted array with duplicates/Search in rotated sorted array II:-
class Solution {

    public boolean search(int[] nums, int target) {

        if (nums.length == 1) {
            return nums[0] == target;
        }

        int pivot = findPivotWithDuplicates(nums);

        // Case 1: Array not rotated
        if (pivot == -1) {
            return binarySearch(nums, target, 0, nums.length - 1) != -1;
        }

        // Case 2: Pivot itself is target
        if (nums[pivot] == target) return true;

        // Case 3: Target in left half
        if (target >= nums[0]) {
            return binarySearch(nums, target, 0, pivot - 1) != -1;
        }

        // Case 4: Target in right half
        return binarySearch(nums, target, pivot + 1, nums.length - 1) != -1;
    }

    // ✅ Correct Pivot Finder with Duplicates
    public int findPivotWithDuplicates(int[] nums) {

        int s = 0;
        int e = nums.length - 1;

        while (s <= e) {

            int m = s + (e - s) / 2;

            // ✅ Case 1
            if (m < e && nums[m] > nums[m + 1]) return m;

            // ✅ Case 2
            if (m > s && nums[m] < nums[m - 1]) return m - 1;

            // ✅ Case 3: Duplicates
            if (nums[s] == nums[m] && nums[m] == nums[e]) {

                if (s < e && nums[s] > nums[s + 1]) return s;
                s++;

                if (e > s && nums[e] < nums[e - 1]) return e - 1;
                e--;
            }

            // ✅ Case 4: Left side sorted OR right unsorted
            else if (nums[s] < nums[m] || (nums[s] == nums[m] && nums[m] > nums[e])) {
                s = m + 1;
            }

            // ✅ Case 5: Pivot in left
            else {
                e = m - 1;
            }
        }
        return -1;
    }

    // ✅ Correct Binary Search
    public int binarySearch(int[] nums, int target, int s, int e) {

        while (s <= e) {

            int m = s + (e - s) / 2;

            if (nums[m] == target) return m;

            if (nums[m] > target) e = m - 1;
            else s = m + 1;
        }

        return -1;
    }
}

3)Rotation count:- find pivot(with no duplicates or duplicates code and then return pivot + 1,as R.C = pivot + 1 always
