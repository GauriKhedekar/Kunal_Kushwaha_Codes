1)Prime numbers:-
public class Main {
    public static void main(String[] args) {
        int n = 40;
        boolean[] prime = new boolean[n];

        // assume all prime
        for (int i = 0; i < n; i++) {
            prime[i] = true;
        }

        prime[0] = prime[1] = false;

        for (int i = 2; i * i < n; i++) {
            if (prime[i]) {
                // start from i*i (not 2*i)
                for (int j = i * i; j < n; j += i) {
                    prime[j] = false;
                }
            }
        }

        for (int i = 2; i < n; i++) {
            if (prime[i]) {
                System.out.println(i);
            }
        }
    }
}

‚ùì Your Doubt (Clear Answer)
Why NOT 2*i? Why i*i?
Multiples < i¬≤ already have a smaller prime factor
They were marked earlier
Starting from 2*i causes duplicate marking
i*i avoids redundant work ‚Üí optimized

üîπ Method Used
Sieve of Eratosthenes
üîπ Why it is called ‚ÄúSieve‚Äù?
Like a sieve/strainer, it:
keeps prime numbers
filters out (marks) multiples (composites)

‚è± Time Complexity (Short & Exact)
Time Complexity
‚úÖ O(n log log n)
Why? (Harmonic Progression)
Total work:
(1)n/2 + (1)n/3 + (1)n/5 + (1)n/7 + ...
= n (1/2 + 1/3 + 1/5 + ...)
‚âà n log log n
üìå This is a harmonic series over primes

üì¶ Space Complexity
‚úÖ O(n)

2)Sqrt of a number:-
Approach 1:-
public class Main {
    public static void main(String[] args) {

        int n = 26;
        int s = 0, e = n;

        // Binary search will NOT give exact square root for non-perfect squares.
        // It only finds the largest integer 'm' such that m*m <= n.
        // This value is called floor(sqrt(n)) and is used as the base
        // to calculate decimal precision later.
        double root = 0.0;

        // -------- INTEGER PART (Binary Search) --------
        while (s <= e) {
            int m = s + (e - s) / 2;

            if (m * m == n) {
                // Perfect square case ‚Üí exact root found
                root = m;
                break;
            }

            if (m * m > n) {
                // m is too large, discard right half
                e = m - 1;
            } else {
                // m*m < n ‚Üí m is a valid candidate
                // Store it because it may be the floor value of sqrt(n)
                root = m;
                s = m + 1;
            }
        }

        // -------- DECIMAL PRECISION PART --------
        // Now we already have floor(sqrt(n)).
        // We increase the root step-by-step to get decimal places.
        int p = 3;          // number of decimal places
        double step = 0.1;

        for (int i = 0; i < p; i++) {
            while (root * root <= n) {
                root += step;
            }
            // when root*root becomes > n, step back
            root -= step;
            step /= 10;     // increase precision (0.1 ‚Üí 0.01 ‚Üí 0.001)
        }

        System.out.println(root);
    }
}
Binary Search ‚Üí O(log n)
Precision Loop ‚Üí O(p)
Total ‚Üí O(log n + p)
#Approach 2:-Newtons Raphson method:-
public class Main {
    public static void main(String[] args) {

        int n = 40;            // Number whose square root we want
        double x = n;          // Initial guess (we start with n itself)
        double root;           // To store the new approximation of sqrt(n)

        // This loop runs until we get a sufficiently accurate answer
        // Time Complexity:
        // Each iteration improves the answer very fast (error reduces exponentially)
        // So total iterations ‚âà log(log n)
        // Overall TC of this method is O(log log n)
        while (true) {

            // Newton-Raphson formula to find square root:
            // new_root = (x + n/x) / 2
            root = 0.5 * (x + (n / x));

            // If difference between new value and old value is very small,
            // we stop because root is accurate enough
            if (Math.abs(root - x) < 1) {
                break;        // error is less than 1, stop iteration
            }

            // Update x with better approximation
            x = root;
        }

        // Print the final square root value
        System.out.println(root);
    }
}
Newton‚ÄìRaphson method runs in O(log N ¬∑ f(N)) time, where f(N) is the cost of evaluating f(x)/f‚Ä≤(x) with N-digit precision, due to quadratic convergence.

3)Factors of a number:-
//T.C:-O(sqrt(n))
//S.C:-In the worst case, a number n can have at most O(‚àön) factors.
import java.util.ArrayList;
public class Main {
    public static void main(String[] args) {
      int n = 20;
      ArrayList<Integer> ans = new ArrayList<Integer>();
      for(int i = 1; i <= Math.sqrt(n); i++){
          if(n % i == 0) {
              ans.add(i);
          }
      }
      //add factors of n which are multiplied with i to get n but in reverse order i.e. factor i.e. multiplied with sqrt of n will come first...
        //first we will start iterating from last index in an existing arraylist and get factor related to it and will add it in an existing arraylist
        for(int i = ans.size() - 1; i >= 0; i--){
            int factor = n / ans.get(i);
            //Incase if n is perfect square then to avoid printing duplicate factors ,e.g if n = 9(perfect square) then ans.get(i) = (n / ans.get(i))(Or factor) = 3 which will lea to [printing 3 twice,to avoid that we have used if condition
            if(ans.get(i) != factor) {
                ans.add(factor);
            }
        }
      System.out.println(ans);

    }
}

4)Modulo Properties:-
üìå Modulo Properties for Programming
Let a, b, c be integers and m > 0 (modulus).

1Ô∏è‚É£ Addition
(a + b) % m = ((a % m) + (b % m)) % m

2Ô∏è‚É£ Subtraction
(a - b) % m = ((a % m) - (b % m) + m) % m
(+ m avoids negative values)

3Ô∏è‚É£ Multiplication
(a * b) % m = ((a % m) * (b % m)) % m

4Ô∏è‚É£ Exponentiation
(a^b) % m = ((a % m)^b) % m
(Use fast power for large b)

5Ô∏è‚É£ Division (Important)
‚ùå Division is not directly allowed in modulo.
‚úî Use multiplicative modulo inverse:
(a / b) % m = (a * b‚Åª¬π) % m

6)(a % m) % m = a % m

7)m^x % m = 0 where x belongs to positive integers

üìå Multiplicative Modulo Inverse
Definition
For a number a under modulo m,
x is called the modulo inverse of a if:
(a * x) % m = 1
Written as:
a‚Åª¬π % m

Condition for Existence
Modulo inverse exists only if:
gcd(a, m) = 1

Ways to Find Modulo Inverse
1Ô∏è‚É£ Extended Euclidean Algorithm
Works for any modulo:
a*x + m*y = 1
Here, x is the modulo inverse.
üîπ Example
Find modulo inverse of a = 3 under modulo m = 11
Using Extended Euclidean Algorithm:
3*4 + 11*(-1) = 1
Taking modulo 11:
3*4 % 11 = 1
‚úÖ So:
3‚Åª¬π % 11 = 4

2Ô∏è‚É£ Fermat‚Äôs Little Theorem : if p is a prime number which is not a divisor of b then,
ab^(p - 1) % p = a % p due to this theorem.

üìå Co-Prime Numbers
Two numbers a and b are co-prime if:
gcd(a, b) = 1
They share no common factor except 1.



